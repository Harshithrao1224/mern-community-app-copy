{"ast":null,"code":"import { isIPv6, isIPv4 } from 'is-ip';\nimport { createPublicIp, IpNotFoundError } from './core.js';\nexport class CancelError extends Error {\n  constructor() {\n    super('Request was cancelled');\n    this.name = 'CancelError';\n  }\n  get isCanceled() {\n    return true;\n  }\n}\nexport { IpNotFoundError } from './core.js';\nconst defaults = {\n  timeout: 5000\n};\nconst urls = {\n  v4: ['https://ipv4.icanhazip.com/', 'https://api.ipify.org/'],\n  v6: ['https://ipv6.icanhazip.com/', 'https://api6.ipify.org/']\n};\nconst sendXhr = (url, options, version) => {\n  const xhr = new XMLHttpRequest();\n  let _reject;\n  const promise = new Promise((resolve, reject) => {\n    _reject = reject;\n    xhr.addEventListener('error', reject, {\n      once: true\n    });\n    xhr.addEventListener('timeout', reject, {\n      once: true\n    });\n    xhr.addEventListener('load', () => {\n      const ip = xhr.responseText.trim();\n      const method = version === 'v6' ? isIPv6 : isIPv4;\n      if (!ip || !method(ip)) {\n        reject();\n        return;\n      }\n      resolve(ip);\n    }, {\n      once: true\n    });\n    xhr.open('GET', url);\n    xhr.timeout = options.timeout;\n    xhr.send();\n  });\n  promise.cancel = () => {\n    xhr.abort();\n    _reject(new CancelError());\n  };\n  return promise;\n};\nconst queryHttps = (version, options) => {\n  let request;\n  const promise = async function () {\n    const urls_ = [...urls[version], ...(options.fallbackUrls ?? [])];\n    let lastError;\n    for (const url of urls_) {\n      try {\n        request = sendXhr(url, options, version);\n        // eslint-disable-next-line no-await-in-loop\n        const ip = await request;\n        return ip;\n      } catch (error) {\n        lastError = error;\n        if (error instanceof CancelError) {\n          throw error;\n        }\n      }\n    }\n    throw new IpNotFoundError({\n      cause: lastError\n    });\n  }();\n  promise.cancel = () => {\n    request.cancel();\n  };\n  return promise;\n};\nexport const publicIp = createPublicIp(publicIpv4, publicIpv6);\nexport function publicIpv4(options) {\n  return queryHttps('v4', {\n    ...defaults,\n    ...options\n  });\n}\nexport function publicIpv6(options) {\n  return queryHttps('v6', {\n    ...defaults,\n    ...options\n  });\n}","map":{"version":3,"names":["isIPv6","isIPv4","createPublicIp","IpNotFoundError","CancelError","Error","constructor","name","isCanceled","defaults","timeout","urls","v4","v6","sendXhr","url","options","version","xhr","XMLHttpRequest","_reject","promise","Promise","resolve","reject","addEventListener","once","ip","responseText","trim","method","open","send","cancel","abort","queryHttps","request","urls_","fallbackUrls","lastError","error","cause","publicIp","publicIpv4","publicIpv6"],"sources":["C:/Users/victo/Desktop/mern-community-app-copy/client/node_modules/public-ip/browser.js"],"sourcesContent":["import {isIPv6, isIPv4} from 'is-ip';\nimport {createPublicIp, IpNotFoundError} from './core.js';\n\nexport class CancelError extends Error {\n\tconstructor() {\n\t\tsuper('Request was cancelled');\n\t\tthis.name = 'CancelError';\n\t}\n\n\tget isCanceled() {\n\t\treturn true;\n\t}\n}\n\nexport {IpNotFoundError} from './core.js';\n\nconst defaults = {\n\ttimeout: 5000,\n};\n\nconst urls = {\n\tv4: [\n\t\t'https://ipv4.icanhazip.com/',\n\t\t'https://api.ipify.org/',\n\t],\n\tv6: [\n\t\t'https://ipv6.icanhazip.com/',\n\t\t'https://api6.ipify.org/',\n\t],\n};\n\nconst sendXhr = (url, options, version) => {\n\tconst xhr = new XMLHttpRequest();\n\n\tlet _reject;\n\tconst promise = new Promise((resolve, reject) => {\n\t\t_reject = reject;\n\t\txhr.addEventListener('error', reject, {once: true});\n\t\txhr.addEventListener('timeout', reject, {once: true});\n\n\t\txhr.addEventListener('load', () => {\n\t\t\tconst ip = xhr.responseText.trim();\n\t\t\tconst method = version === 'v6' ? isIPv6 : isIPv4;\n\n\t\t\tif (!ip || !method(ip)) {\n\t\t\t\treject();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(ip);\n\t\t}, {once: true});\n\n\t\txhr.open('GET', url);\n\t\txhr.timeout = options.timeout;\n\t\txhr.send();\n\t});\n\n\tpromise.cancel = () => {\n\t\txhr.abort();\n\t\t_reject(new CancelError());\n\t};\n\n\treturn promise;\n};\n\nconst queryHttps = (version, options) => {\n\tlet request;\n\tconst promise = (async function () {\n\t\tconst urls_ = [\n\t\t\t...urls[version],\n\t\t\t...(options.fallbackUrls ?? []),\n\t\t];\n\n\t\tlet lastError;\n\t\tfor (const url of urls_) {\n\t\t\ttry {\n\t\t\t\trequest = sendXhr(url, options, version);\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tconst ip = await request;\n\t\t\t\treturn ip;\n\t\t\t} catch (error) {\n\t\t\t\tlastError = error;\n\n\t\t\t\tif (error instanceof CancelError) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new IpNotFoundError({cause: lastError});\n\t})();\n\n\tpromise.cancel = () => {\n\t\trequest.cancel();\n\t};\n\n\treturn promise;\n};\n\nexport const publicIp = createPublicIp(publicIpv4, publicIpv6);\n\nexport function publicIpv4(options) {\n\treturn queryHttps('v4', {...defaults, ...options});\n}\n\nexport function publicIpv6(options) {\n\treturn queryHttps('v6', {...defaults, ...options});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}